clear
close all
rng(1) %seed to get same outcomes every time
%{
Inverse modeling 1D DC resistivity measurements. Based on tdmcmc_teaching
example. Use with calculateRho1D, genericMedium, and mcmcAlgorithm.
 Chris Mills 10/2020
%}

ifLoadEnsemble = input('Load previous ensemble? true/false');

if ~ifLoadEnsemble
    %% Set inversion options
    forwardModel = @(a,b,c) calculateRho1D(a,b,c);
    options.kMax = 10; %max number of layers allowed in models
    options.numSteps = 1e4; %total iterations for MCMC loop. 1e7+ recommended
    options.mLPSCoefficient = 1e4;
    %mLPS = max layers per step. Set higher for longer burn-in period.
    %saveStart is the # of steps before end to start sampling. Should not
    %sample until max # of layers has been reached AND it has had time to test
    %a few models with max # of layers.
    options.saveStart = floor(options.numSteps/2);
    options.saveSkip = 10; %sample every (saveSkip)th step once sampling begins
    options.samplePrior = false; % always accept proposed solution
    options.intlVar = 1.0; %variance = how much misfit accepted.
    options.alterVar = true; %If false, model variance will never change

    if options.mLPSCoefficient*sum(2:options.kMax) > options.numSteps
        options.mLPSCoefficient = floor(options.numSteps/sum(2:options.kMax));
        disp(['Not enough steps, changing burn-in time']);
    end
    if options.numSteps - options.saveStart < options.mLPSCoefficient*...
            (sum(2:options.kMax-1)+(0.5*options.kMax))
        options.saveStart = options.numSteps - (options.mLPSCoefficient*...
            ceil(sum(2:options.kMax-1)+(0.5*options.kMax)));
        disp(['Changing saveStart time']);
    end

    %% Define and measure starting model
    ifLoadData = input('Load data? true/false\n');

    if ifLoadData
        % ...Not setup yet to take real data
    else
        %Measurement options
        measure.minDist = 0.1; % Smallest electrode distance, meters
        measure.maxDist = 1000; %  Largest electrode distance, meters
        measure.numMeasurements = 21; %total # of measurements between minDist,maxDist
        measure.noiseCoef = 0.1; %How "noisy" are the measurements, smaller values = less noisy

        %  true model definition
        measure.modelChoice = '4LayerA'; %choice of model. '3LayerA' or '4LayerA'

        measure.kMax = options.kMax;
        data = createSyntheticData(measure);
    end

%% Do the thing
results = mcmcAlgorithm(data,forwardModel,options); %Do the inversion

ifSave = input('save?\n');
if ifSave
    filename = ['Ensemble_', modelChoice, '_',...
        num2str(measure.noiseCoef), '_', date, '.mat'];
    save(filename,'results','trueDepths','trueRhos','x','y','fx',...
        'options','measure','model');
end

%% Calculate and measure "mean" model
%Model represents the mean of all models (at each depth, the mean
%resistivity across all saved models for that depth)
%disp(['Creating mean model']);
%meanModel = createMeanModel(options.kMax,measure,results);

%% Plot Run Properties
disp(['Plotting']);
ensembleAnalysis(results,measure,forwardModel);

